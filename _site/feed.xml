<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hu&#39;s Space !</title>
    <description>This is personnel website of HuTianyun</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 23 Oct 2017 23:08:23 +0800</pubDate>
    <lastBuildDate>Mon, 23 Oct 2017 23:08:23 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title> Pygame Notebook 3</title>
        <description>&lt;h1 id=&quot;making-games-with-python-and-pygame&quot;&gt;《Making Games with Python and Pygame》&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;notebook-3&quot;&gt;Notebook &amp;lt;3&amp;gt;&lt;/h2&gt;
&lt;p&gt;第六章的游戏 Wormy 贪吃蛇游戏， 开局显示旋转变化的字体和方块，按下任意按键后会显示游戏界面，划分的网格，游走的蛇（绿色方块），苹果（红色的方块），碰撞到苹果身体变长，碰撞到自己和墙壁游戏结束，暂停并显示 Game Over，按下任意按键后又再次重新开始。同时实时显示分数。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;亮点 / 思路&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;程序很好的结合了吃苹果和游动的处理，使用蛇头坐标，一个字典列表表示蛇，每次都删除末尾，吃到则不删除。&lt;/li&gt;
  &lt;li&gt;Game Over时，进入显示Game Over while 死循环等待退出，其间其他的显示部分暂停在原处，死循环阻塞住了其他显示程序，显示程序仍旧在 Surface 上面显示界面，造成一种另外有暂停程序的假象。&lt;/li&gt;
  &lt;li&gt;字体背景会随着字体的变化而变化，不需要额外控制。&lt;/li&gt;
  &lt;li&gt;2D 图像的旋转，不完美，不应该直接覆盖变量，复用变量名的话则会造成字体的 Surface 越来越大，报错。&lt;/li&gt;
  &lt;li&gt;智能的退出函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;蛇的表示和长度的增加&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在当前的前进方向上增加头，删去尾巴，每次重新绘图时感觉就是在前进；吃到苹果则不删去，感觉就是增加了长度。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;wormCoords = [ {&#39;x&#39;:startx , &#39;y&#39;: starty} ,  {&#39;x&#39;:startx-1 , &#39;y&#39;: starty}  ,  {&#39;x&#39;:startx-2 , &#39;y&#39;: starty} ,{&#39;x&#39;:startx-3 , &#39;y&#39;: starty} ]
if wormCoords[HEAD][&#39;x&#39;] == apple[&#39;x&#39;] and wormCoords[HEAD][&#39;y&#39;] == apple[&#39;y&#39;]:
	apple = getRandomLocation() # set a new apple somewhere
else:
	del wormCoords[-1] 

if direction == UP:
	newHead = {&#39;x&#39;: wormCoords[HEAD][&#39;x&#39;], &#39;y&#39;: wormCoords[HEAD][&#39;y&#39;] - 1}
elif direction == DOWN:
	newHead = {&#39;x&#39;: wormCoords[HEAD][&#39;x&#39;], &#39;y&#39;: wormCoords[HEAD][&#39;y&#39;] + 1}
elif direction == LEFT:
	newHead = {&#39;x&#39;: wormCoords[HEAD][&#39;x&#39;] - 1, &#39;y&#39;: wormCoords[HEAD][&#39;y&#39;]}
elif direction == RIGHT:
	newHead = {&#39;x&#39;: wormCoords[HEAD][&#39;x&#39;] + 1, &#39;y&#39;: wormCoords[HEAD][&#39;y&#39;]}

wormCoords.insert(0, newHead)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;pygameevent--type-&quot;&gt;显示 pygame.event 中的 type 值&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/assets/files/Pygame_book/my_event_test.py&quot;&gt;运行文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;#/usr/bin/env python
#coding=utf8

import random, pygame, sys
from pygame.locals import *

WINDOWWIDTH = 640
WINDOWHEIGHT = 480

def main():
	pygame.init()
	DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))
	pygame.display.set_caption(&#39;event test&#39;)


	while True:
for event in pygame.event.get():
	print &#39;event.type&#39; , event.type

	if event.type == QUIT:
pygame.quit()
sys.exit()
	elif event.type == KEYDOWN:
print event.key 


if __name__ == &#39;__main__&#39;:
	main()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;显示 文字旋转，背景转化，网格划分，按键退出&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/assets/files/Pygame_book/my_wormy_test.py&quot;&gt;运行文件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;背景转化更好的说明了每次用背景色覆盖后重新绘图的原理和好处&lt;/li&gt;
  &lt;li&gt;文字旋转&lt;br /&gt;
 &amp;gt; pygame.transform.rotate( surface , rotate_angle) 并不会改变传递给它的 Surface 对象，而是返回一个新的Surface 对象，旋转后的图形绘制于新的 Surface 对象上。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以每次都重新绘图。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;旋转不要复用变量名。&lt;br /&gt;
 &amp;gt; pygame.error: Width or height is too large&lt;/li&gt;
  &lt;li&gt;退出函数 checkForKeyPress() 的使用&lt;/li&gt;
  &lt;li&gt;网格划分，循环划线。&lt;br /&gt;
```Python&lt;br /&gt;
#/usr/bin/env python&lt;br /&gt;
#coding=utf8&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;import random, pygame, sys&lt;br /&gt;
from pygame.locals import *&lt;/p&gt;

&lt;p&gt;FPS = 5&lt;br /&gt;
WINDOWWIDTH = 640&lt;br /&gt;
WINDOWHEIGHT = 480&lt;br /&gt;
CELLSIZE = 20&lt;br /&gt;
assert WINDOWWIDTH % CELLSIZE == 0, “Window width must be a multiple of cell size.”&lt;br /&gt;
assert WINDOWHEIGHT % CELLSIZE == 0, “Window height must be a multiple of cell size.”&lt;br /&gt;
CELLWIDTH = int(WINDOWWIDTH / CELLSIZE)&lt;br /&gt;
CELLHEIGHT = int(WINDOWHEIGHT / CELLSIZE)&lt;/p&gt;

&lt;h1 id=&quot;rgb&quot;&gt;R	G	B&lt;/h1&gt;
&lt;p&gt;WHITE	 = (255, 255, 255)&lt;br /&gt;
BLACK	 = (  0,   0,   0)&lt;br /&gt;
RED	   = (255,   0,   0)&lt;br /&gt;
GREEN	 = (  0, 255,   0)&lt;br /&gt;
DARKGREEN = (  0, 155,   0)&lt;br /&gt;
DARKGRAY  = ( 40,  40,  40)&lt;br /&gt;
BGCOLOR = BLACK&lt;/p&gt;

&lt;p&gt;def terminate():&lt;br /&gt;
	pygame.quit()&lt;br /&gt;
	sys.exit()&lt;/p&gt;

&lt;p&gt;def main():&lt;br /&gt;
	global FPSCLOCK, DISPLAYSURF, BASICFONT&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pygame.init()
FPSCLOCK = pygame.time.Clock()
DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))
BASICFONT = pygame.font.Font(&#39;freesansbold.ttf&#39;, 18)
pygame.display.set_caption(&#39;Wormy&#39;)

degrees1 = 0
degrees2 = 0

while True:
	
	showStartScreen()
	showGameOverScreen()

print &#39;exit&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;def drawGrid():&lt;br /&gt;
	for x in range(0, WINDOWWIDTH, CELLSIZE): # draw vertical lines&lt;br /&gt;
		pygame.draw.line(DISPLAYSURF, DARKGRAY, (x, 0), (x, WINDOWHEIGHT))&lt;br /&gt;
	for y in range(0, WINDOWHEIGHT, CELLSIZE): # draw horizontal lines&lt;br /&gt;
		pygame.draw.line(DISPLAYSURF, DARKGRAY, (0, y), (WINDOWWIDTH, y))&lt;br /&gt;
def drawPressKeyMsg():&lt;br /&gt;
	pressKeySurf = BASICFONT.render(‘Press a key to play.’, True, DARKGRAY)&lt;br /&gt;
	pressKeyRect = pressKeySurf.get_rect()&lt;br /&gt;
	pressKeyRect.topleft = (WINDOWWIDTH - 200, WINDOWHEIGHT - 30)&lt;br /&gt;
	DISPLAYSURF.blit(pressKeySurf, pressKeyRect)&lt;/p&gt;

&lt;p&gt;def checkForKeyPress():&lt;br /&gt;
	if len(pygame.event.get(QUIT)) &amp;gt; 0:&lt;br /&gt;
		terminate()&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;keyUpEvents = pygame.event.get(KEYUP)
if len(keyUpEvents) == 0:
	return None
if keyUpEvents[0].key == K_ESCAPE:
	terminate()
return keyUpEvents[0].key
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;def showStartScreen():&lt;br /&gt;
	titleFont = pygame.font.Font(‘freesansbold.ttf’, 100)&lt;br /&gt;
	titleSurf1 = titleFont.render(‘Wormy!’, True, WHITE, DARKGREEN)&lt;br /&gt;
	titleSurf2 = titleFont.render(‘Wormy!’, True, GREEN)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;degrees1 = 0
degrees2 = 0
while True:

	# DISPLAYSURF.fill(BGCOLOR)
	rotatedSurf1 = pygame.transform.rotate(titleSurf1, degrees1) #返回的是新的 Surface 对象
	rotatedRect1 = rotatedSurf1.get_rect()
	rotatedRect1.center = (WINDOWWIDTH / 2, WINDOWHEIGHT / 2)
	DISPLAYSURF.blit(rotatedSurf1, rotatedRect1)

	rotatedSurf2 = pygame.transform.rotate(titleSurf2, degrees2) 
	rotatedRect2 = rotatedSurf2.get_rect()
	rotatedRect2.center = (WINDOWWIDTH / 2, WINDOWHEIGHT / 2)
	DISPLAYSURF.blit(rotatedSurf2, rotatedRect2)

	# for event in pygame.event.get():
	# 	if event.type == QUIT:
	# 		terminate()

	if checkForKeyPress():
		pygame.event.get() # clear event queue
		return
	drawPressKeyMsg()
	drawGrid()
	pygame.display.update()
	FPSCLOCK.tick(FPS)
	degrees1 += 3 # rotate by 3 degrees each frame
	degrees2 += 7 # rotate by 7 degrees each frame
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;def showGameOverScreen():&lt;br /&gt;
	gameOverFont = pygame.font.Font(‘freesansbold.ttf’, 150)&lt;br /&gt;
	gameSurf = gameOverFont.render(‘Game’, True, WHITE)&lt;br /&gt;
	overSurf = gameOverFont.render(‘Over’, True, WHITE)&lt;br /&gt;
	gameRect = gameSurf.get_rect()&lt;br /&gt;
	overRect = overSurf.get_rect()&lt;br /&gt;
	gameRect.midtop = (WINDOWWIDTH / 2, 10)&lt;br /&gt;
	overRect.midtop = (WINDOWWIDTH / 2, gameRect.height + 10 + 25)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DISPLAYSURF.blit(gameSurf, gameRect)
DISPLAYSURF.blit(overSurf, overRect)

drawPressKeyMsg()

pygame.display.update()
pygame.time.wait(500)
checkForKeyPress() # clear out any key presses in the event queue

while True:
	if checkForKeyPress():
		pygame.event.get() # clear event queue
		return
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;if &lt;strong&gt;name&lt;/strong&gt; == ‘&lt;strong&gt;main&lt;/strong&gt;’:&lt;br /&gt;
	main()&lt;br /&gt;
```&lt;/p&gt;
</description>
        <pubDate>Mon, 23 Oct 2017 00:00:00 +0800</pubDate>
        <link>/python/2017/10/23/pygame-note3.html</link>
        <guid isPermaLink="true">/python/2017/10/23/pygame-note3.html</guid>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title> Pygame Notebook 2</title>
        <description>&lt;h1 id=&quot;making-games-with-python-and-pygame&quot;&gt;《Making Games with Python and Pygame》&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;notebook-2&quot;&gt;Notebook &amp;lt;2&amp;gt;&lt;/h2&gt;
&lt;p&gt;第五章的游戏 Simulate，让人去记住并重复游戏中图案显示的顺序， 主体还是画出矩形并能和鼠标键盘交互，在此之上增加了点击矩形时的音乐，一些类似特效的光影闪烁效果和实现显示的记分牌。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;一般的逻辑顺序&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;导入模块，设置全局变量，常量。&lt;/li&gt;
  &lt;li&gt;设置界面，局部变量
    &lt;ol&gt;
      &lt;li&gt;文字 Surface 字体，大小，位置。&lt;/li&gt;
      &lt;li&gt;按键的颜色，大小，位置。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;While 循环 &lt;strong&gt;【在循环检测 QUIT 事件，否则是死循环无法退出】&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;在循环中检测按键光标事件，检测碰撞。&lt;/li&gt;
      &lt;li&gt;循环中不断重新绘制全局和局部的 Surface。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-1&quot;&gt;亮点 / 思路&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;所绘制的图标与图标占用的方块仅仅是大小相同，其他并没有什么联系。所以图标重新绘制和光标的碰撞到方块的检测并不矛盾和冲突，相反我觉得这是一种很好的思路和编写方式。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;
# 绘制 rect vs rect 检测
draw_rect( )
pygame.Rect( )
# 重复绘制图标
drawButtons()
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;其实在前两章和本章的源码的循环中都有用背景色覆盖所有，然后再重新绘制文字，图标的部分，在搞清能这样的原因后，这样做的好处我觉得也有这样几条：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;
编写逻辑更加简单粗暴了，更新界面实际上就是整体重新绘制，不是界面的小修小补。
方便在界面上显示需要更新的文字【这里应该也可以小修小补的】，或是实时变更的分数等消息。
&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;功能&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Python
#让 Surface 显示出现在屏幕上
pygame.display.update()
# 确保动画不会像计算机绘制那样快的播放，调用 tick() 增加暂停，FPS 越小越慢
FPSCLOCK.tick(FPS)
&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;播放音乐&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/assets/files/Pygame_book/beep1.ogg&quot;&gt;音乐文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;# -*- coding: utf-8 -*-

import pygame,sys
from pygame.locals import *
import time
WINDOWWIDTH = 640
WINDOWHEIGHT = 480

global FPSCLOCK, DISPLAYSURF, BEEP1
pygame.init()
FPSCLOCK = pygame.time.Clock()
DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))

pygame.display.set_caption(&#39;Play Sound&#39;)
BEEP1 = pygame.mixer.Sound(&#39;beep1.ogg&#39;)

while True:
	for event in pygame.event.get(): # event handling loop
		if event.type == MOUSEBUTTONUP:
			mousex, mousey = event.pos
			BEEP1.play()

		if event.type == QUIT:
			pygame.quit()
			sys.exit()

	pygame.display.update()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;### 颜色效果的制作&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过不断更改透明度 alpha 实现颜色的明暗变化效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;调用 convert_alpha() 方法，以便该 Surface 对象能够具有一个绘制于图上的透明色，否则的话将会忽略 Color 对象的 alpha 值并自动保存为 255。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;# -*- coding: utf-8 -*-

import pygame,sys,random
from pygame.locals import *
import time
FPS = 30
WINDOWWIDTH = 640
WINDOWHEIGHT = 480

#	R	G	B
WHITE	= (255, 255, 255)
BLACK	= (  0,   0,   0)

bgColor = BLACK

def changeBackgroundAnimation(animationSpeed=5):
	global bgColor
	newBgColor = (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))

	newBgSurf = pygame.Surface((WINDOWWIDTH, WINDOWHEIGHT))
	newBgSurf = newBgSurf.convert_alpha()
	r, g, b = newBgColor
	for alpha in range(0, 255, animationSpeed): # animation loop
		DISPLAYSURF.fill(bgColor)

		newBgSurf.fill((r, g, b, alpha))
		DISPLAYSURF.blit(newBgSurf, (0, 0))

		pygame.display.update()
		FPSCLOCK.tick(FPS)
	bgColor = newBgColor

def main():
	global FPSCLOCK, DISPLAYSURF
	pygame.init()
	FPSCLOCK = pygame.time.Clock()
	DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))
	pygame.display.set_caption(&#39;Color&#39;)

	while True:
		for event in pygame.event.get(): # event handling loop
			if event.type == MOUSEBUTTONUP:
				mousex, mousey = event.pos
				changeBackgroundAnimation()
			if event.type == QUIT:
				pygame.quit()
				sys.exit()
				
		pygame.display.update()

if __name__ == &#39;__main__&#39;:
	main()
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Sat, 21 Oct 2017 00:00:00 +0800</pubDate>
        <link>/python/2017/10/21/pygame-note2.html</link>
        <guid isPermaLink="true">/python/2017/10/21/pygame-note2.html</guid>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title> Pygame Notebook 1</title>
        <description>&lt;h1 id=&quot;making-games-with-python-and-pygame&quot;&gt;《Making Games with Python and Pygame》&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;notebook-1&quot;&gt;Notebook &amp;lt;1&amp;gt;&lt;/h2&gt;
&lt;p&gt;在半敲半复制了第三章 Memory Puzzle 和第四章 Slide Puzzle 的源码之后，结合前两章节所讲的东西算是对如何使用 Pygame 编写一个带有界面和操作的小游戏有了基本的认识和了解。这两章的代码主要功能都是在 原始的 Surface 上面绘制带有颜色和文字内容的矩形块，并能对鼠标键盘等操作进行响应。抛开其中简单的数学图形计算不谈，先把其中 Pygame 编写的思路和 API 的调用方式记录下。&lt;/p&gt;

&lt;h3 id=&quot;memory-puzzle--slide-puzzle&quot;&gt;Memory Puzzle &amp;amp; Slide Puzzle&lt;/h3&gt;
&lt;p&gt;#### 像素坐标系和矩形坐标系的转化&lt;br /&gt;
 * 两个源码都始终用的是矩形左上角的像素坐标值进行选择和计算&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;def leftTopCoordsOfBox(boxx , boxy):
	# Convert board coordinates to pixel coordinates
	left = boxx * (BOXSIZE + GAPSIZE ) + XMARGIN
	top  = boxy * (BOXSIZE + GAPSIZE ) + YMARGIN
	return (left , top)

def getLeftTopOfTile(tileX, tileY):
	left = XMARGIN + (tileX * TILESIZE) + (tileX - 1)
	top = YMARGIN + (tileY * TILESIZE) + (tileY - 1)
	return (left, top)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section&quot;&gt;获取光标像素位置，获取键盘值&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;获取光标像素位置，检查光标位于哪一个方块上&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;for event in pygame.event.get():
	event.type == MOUSEMOTION:#or other types
		mousex , mousey = event.pos

# 遍历所有的矩形，检查鼠标与哪一个矩形碰撞了
# 返回矩形所在的行列值，注意坐标系的规定
def getSpotClicked(board, x, y):
    # from the x &amp;amp; y pixel coordinates, get the x &amp;amp; y board coordinates
	for tileX in range(len(board)):
		for tileY in range(len(board[0])):
			left, top = getLeftTopOfTile(tileX, tileY)
			tileRect = pygame.Rect(left, top, TILESIZE, TILESIZE)
			if tileRect.collidepoint(x, y):
				return (tileX, tileY)
	return (None, None)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;获取键盘值&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;for event in pygame.event.get():
	if event.type == KEYUP:
		if event.key in (K_LEFT, K_a) and isValidMove(mainBoard, LEFT):
			slideTo = LEFT
		elif event.key in (K_RIGHT, K_d) and isValidMove(mainBoard, RIGHT):
			slideTo = RIGHT
		elif event.key in (K_UP, K_w) and isValidMove(mainBoard, UP):
			slideTo = UP
		elif event.key in (K_DOWN, K_s) and isValidMove(mainBoard, DOWN):
			slideTo = DOWN 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;使用 assert 语句检查&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;assert (BOARDWIDTH * BOARDHEIGHT) %2 == 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;#### import random &lt;br /&gt;
 * 截取列表前 numIconsUsed 个， 打乱列表&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;icons = icons[:numIconsUsed] * 2
random.shuffle(icons)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;pygame-&quot;&gt;Pygame 绘制思路&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;导入模块&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;import pygame,sys
from pygame.locals import *
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;启动，设置全部变量，窗口大小，标题，字体&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;global FPSCLOCK , DISPLAYSURF , BASICFONT
pygame.init()
FPSCLOCK = pygame.time.Clock()
DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH , WINDOWHEIGHT))
pygame.display.set_caption(&#39;NAME&#39;)
BASICFONT = pygame.font.Font(&#39;freesansbold.ttf&#39; , BASICFONTSIZE)

# 设置字体抗锯齿，颜色，背景颜色
def makeText(text, color, bgcolor, top, left):
	# create the Surface and Rect objects for some text.
	textSurf = BASICFONT.render(text, True, color, bgcolor) #返回的是字体的 Surface
	textRect = textSurf.get_rect()
	textRect.topleft = (top, left)
	return (textSurf, textRect)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;更新绘图，帧数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;pygame.display.update()
FPSCLOCK.tick(FPS)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;在 Slide Puzzle 中通过不断地重设背景颜色，不断地&lt;strong&gt;重复绘制&lt;/strong&gt;，层叠Surface整体  从而实现效果。&lt;/li&gt;
  &lt;li&gt;矩形方块的打开覆盖，贴片的滑动是通过绘制大小不一的矩形图案实现的。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;	drawBoard(board, message)  #每次都重新绘制整个图
	baseSurf = DISPLAYSURF.copy() # 深度拷贝
	# draw a blank space over the moving tile on the baseSurf Surface.
	moveLeft, moveTop = getLeftTopOfTile(movex, movey)
	pygame.draw.rect(baseSurf, BGCOLOR, (moveLeft, moveTop, TILESIZE, TILESIZE)) #用背景色方块替换原来的

	for i in range(0, TILESIZE, animationSpeed):
	# animate the tile sliding over
		checkForQuit()
		DISPLAYSURF.blit(baseSurf, (0, 0)) # 覆盖空白方块后继续画图，显示移动
		if direction == UP:
			drawTile(movex, movey, board[movex][movey], 0, -i)
		if direction == DOWN:
			drawTile(movex, movey, board[movex][movey], 0, i)
		if direction == LEFT:
			drawTile(movex, movey, board[movex][movey], -i, 0)
		if direction == RIGHT:
			drawTile(movex, movey, board[movex][movey], i, 0)
	
		pygame.display.update()
		FPSCLOCK.tick(FPS)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;Start , Reset 等按键是通过检测相同位置的矩形范围是否与光标碰撞实现的。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;#画矩形
pygame.draw.rect(baseSurf, BGCOLOR, (moveLeft, moveTop, TILESIZE, TILESIZE))
#利用矩形所在位置进行检测
boxRect = pygame.Rect(left , top , BOXSIZE , BOXSIZE)
if boxRect.collidepoint(event.pos):
	fun_def()
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 21 Oct 2017 00:00:00 +0800</pubDate>
        <link>/python/2017/10/21/pygame-note1.html</link>
        <guid isPermaLink="true">/python/2017/10/21/pygame-note1.html</guid>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title> Jekyll install in Ubuntu</title>
        <description>&lt;h2 id=&quot;jekyll-install-in-ubuntu&quot;&gt;jekyll install in Ubuntu&lt;/h2&gt;

&lt;h3 id=&quot;ubuntu--jekyll-&quot;&gt;Ubuntu 安装 jekyll 时遇到的一些问题。&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;开始时 使用命令&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ruby -v	
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;会发现 Ubuntu 中竟然有一个 ruby1.8，许多网站都说 Ubuntu 中是不自带 ruby 的。但是这个 ruby 貌似没什么用，jekyll 基本都要 ruby &amp;gt; 1.9 或是 &amp;gt;2.0 。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;安装缓慢，改变安装源&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/
  gem sources -l 查看源 确保源里面只有 https://gems.ruby-china.org/ 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 jekyll serve 遇到一些像 GitHub 权限等问题，使用&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  bundle exec jekyll serve
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编译全局，会将所有的内容放到 _site 中&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  jekyll build
  bundle exec jekyll build
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;theme-&quot;&gt;Theme 下载后使用的一些问题&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;一开始使用一些模板时会出现一堆的错误，慢慢看错误，Google就行，基本都能找到答案。两个包可以安装下&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  gem install minima 
  gem install jekyll-feed
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt; 修改文字，添加图片预览时的 网页地址，最好将_config.yml 中的 原始网页先注释掉，不然会联网回到 github 里保存的而不是修改完成的。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;xxx.md 与 xxx.html 在编辑时是同步更新的，不需要 build 后再启动 serve。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;include/ 里面使用的 HTML bootstrap 语言，一些相关的布局语法可以Google。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 19 Oct 2017 00:00:00 +0800</pubDate>
        <link>/ubuntu/2017/10/19/jekll-install-ubuntu.html</link>
        <guid isPermaLink="true">/ubuntu/2017/10/19/jekll-install-ubuntu.html</guid>
        
        
        <category>Ubuntu</category>
        
      </item>
    
      <item>
        <title>Composite Blade Design</title>
        <description>&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;CN&lt;/th&gt;
      &lt;th&gt;ENG&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;复合材料层合板计算&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/Eacaen/composite-blade-design&quot; title=&quot;CLT&quot;&gt;Composite Material Calculation with CLT&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#composite-material-calculation-with-clt&quot;&gt;Introduction&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;开闭剖面多闭室工程梁计算&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;https://github.com/Eacaen/composite-blade-design&quot; title=&quot;CLT&quot;&gt;Engineer Beam Calculation with open or closed profile&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#engineer-beam-calculation-with-open-or-closed-profile&quot;&gt;Introduction&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;read the program introduction for more details &lt;/code&gt; &lt;a href=&quot;/doc/pro_introduction.pdf&quot;&gt;Here&lt;/a&gt;  &lt;br /&gt;
&lt;a href=&quot;#running-requirements&quot;&gt;Running requirements&lt;/a&gt; | &lt;a href=&quot;#installation&quot;&gt;Installation&lt;/a&gt; | &lt;a href=&quot;#license&quot;&gt;License&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;my-bachelor-thesis-in-tubs-germany-partly-finished-we-can-improve-it-together-in-future&quot;&gt;My bachelor thesis in TUBS, Germany, partly finished. We can improve it together in future.&lt;/h4&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;composite-material-calculation-with-clt&quot;&gt;Composite Material Calculation with CLT&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The main package is a Python composite materials calculation package.&lt;br /&gt;
The laminate stresses, strain and failure Criterion based on the Classical Lamination Theory (&lt;a href=&quot;https://en.wikipedia.org/wiki/Composite_laminates&quot;&gt;CLT&lt;/a&gt;).&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;You can define the lamina’s fibre and matrix’s parameters like the Elastic moduli&lt;br /&gt;
  &lt;img src=&quot;http://latex.codecogs.com/gif.latex?E_{1},E_{2}&quot; alt=&quot;&quot; /&gt;,&lt;br /&gt;
   Shear moduli &lt;img src=&quot;http://latex.codecogs.com/gif.latex?G&quot; alt=&quot;&quot; /&gt; and strength, then define lamina’s layer angle and thickness in the next step.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;After define the lamina you can get the matrix such as &lt;img src=&quot;http://latex.codecogs.com/gif.latex?A%2CB%2CD%2CQ%2C%5Cbar%7BQ%7D&quot; alt=&quot;A,B,D,Q&quot; /&gt; and so on by use the &lt;strong&gt;&lt;em&gt;Laminate class&lt;/em&gt;&lt;/strong&gt; or you can define the laminate directly.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Use the &lt;strong&gt;&lt;em&gt;Load class&lt;/em&gt;&lt;/strong&gt; and load the force and moment to the laminate to calculate the stress &lt;img src=&quot;http://latex.codecogs.com/gif.latex?\\sigma&quot; alt=&quot;&quot; /&gt; and stain &lt;img src=&quot;http://latex.codecogs.com/gif.latex?\\epsilon&quot; alt=&quot;&quot; /&gt; of each lamina.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Use the &lt;strong&gt;&lt;em&gt;Failure_Cirterion class&lt;/em&gt;&lt;/strong&gt; and you can choose different theories to check witch lamina failure or not.&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/post_img/lammmm.png&quot; alt=&quot;Laminate in composite&quot; title=&quot; Laminate &quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;em&gt;laminate_plugin.py&lt;/em&gt; can plot the stress and strain distribution in the laminate in the COS(xy or 12), print the results in &lt;em&gt;Excel&lt;/em&gt; formate and save it in &lt;em&gt;Excel&lt;/em&gt;.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/post_img/stress_in_web.png&quot; alt=&quot;stress distribution in laminate &quot; title=&quot; stress distribution &quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;engineer-beam-calculation-with-open-or-closed-profile&quot;&gt;Engineer Beam Calculation with open or closed profile&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;You need to distinguish the shape of the profile, open, closed or mixed and choose the right functions to calculate.
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;You can give the coordinate value of the points of the profile in a &lt;em&gt;Excel&lt;/em&gt; table, you may also need to add or remove some edges, change the thickness between the edges of the profile generated by the &lt;strong&gt;&lt;em&gt;read_exe class&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Use the &lt;strong&gt;&lt;em&gt;profile_constant class&lt;/em&gt;&lt;/strong&gt; to calculate the profile’s engineer constant like the second moment of area &lt;br /&gt;
  &lt;img src=&quot;http://latex.codecogs.com/gif.latex?I_{x},I_{y},I_{xy}&quot; alt=&quot;&quot; /&gt; and use the parameters in the next steps, you can also choose whether move the profile to its centroid.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;If the profile is a open one, you can use the &lt;strong&gt;&lt;em&gt;open_profile class&lt;/em&gt;&lt;/strong&gt; directly, it can calculate the &lt;br /&gt;
  &lt;img src=&quot;http://latex.codecogs.com/gif.latex?S_{x},S_{y}&quot; alt=&quot;&quot; /&gt; and the give the &lt;em&gt;Shear Flow&lt;/em&gt; distribution under the shear force &lt;img src=&quot;http://latex.codecogs.com/gif.latex?Q_{x},Q_{y}&quot; alt=&quot;&quot; /&gt; along the path you choose and you can get the shear center if need.&lt;/li&gt;
      &lt;li&gt;If the profile is a close one with more than one close cells, you need to choose cut points to make the profile become a open one, then choose the integrate paths and use the &lt;strong&gt;&lt;em&gt;open_profile class&lt;/em&gt;&lt;/strong&gt; to get the shear flow in the ‘open’ profile. Last,  use the functions in &lt;strong&gt;&lt;em&gt;close_profile.py&lt;/em&gt;&lt;/strong&gt; to get the shear flow in each close cell, get the shear center, get the twist angle and some more results you need.&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;http://latex.codecogs.com/gif.latex?S_%7Bx%7D%3D%20%5Cint_%7BA%7D%5E%7B%20%7D%20ydA&quot; alt=&quot;&quot; /&gt;  &lt;br /&gt;
  &lt;img src=&quot;http://latex.codecogs.com/gif.latex?S_%7By%7D%3D%20%5Cint_%7BA%7D%5E%7B%20%7D%20xdA&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;plug-ins-use-to-plot-the-results-in-2d-or-3d&quot;&gt;Plug-ins use to plot the results in 2D or 3D.&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/post_img/beam_location.png&quot; alt=&quot;profile&quot; title=&quot;Profile with order&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/post_img/sF-full.gif&quot; alt=&quot;profile at Qx&quot; title=&quot;Profile at Qx&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/post_img/sF-full2.gif&quot; alt=&quot;profile at Qy&quot; title=&quot;Profile at Qy&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;running-requirements&quot;&gt;Running requirements&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Python &amp;gt; v2.7
Numpy
Scipy
Sympy
matplotlib
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;installation&quot;&gt;Installation&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;Copy the source files in the local directory and add the PATH in the system or copy the files to the Python’s “site-packages” folder.  &lt;br /&gt;
Copy the source file in you own file and develop the new function by yourself.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;license&quot;&gt;License&lt;/h3&gt;

&lt;h4 id=&quot;my-graduation-thesis-in-tubspartly-finish&quot;&gt;MY GRADUATION THESIS IN TUBS,PARTLY FINISH.&lt;/h4&gt;

&lt;h4 id=&quot;download-here-httpsgithubcomeacaencomposite-blade-design&quot;&gt;&lt;a href=&quot;https://github.com/Eacaen/composite-blade-design&quot;&gt; Download here &lt;/a&gt;&lt;/h4&gt;
&lt;hr /&gt;

</description>
        <pubDate>Tue, 17 Oct 2017 00:00:00 +0800</pubDate>
        <link>/python/2017/10/17/composite-blade-design.html</link>
        <guid isPermaLink="true">/python/2017/10/17/composite-blade-design.html</guid>
        
        
        <category>Python</category>
        
      </item>
    
  </channel>
</rss>
