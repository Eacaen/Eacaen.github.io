<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hu's Space !</title>
    <description>This is personnel website of HuTianyun</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 21 Nov 2017 01:17:20 +0800</pubDate>
    <lastBuildDate>Tue, 21 Nov 2017 01:17:20 +0800</lastBuildDate>
    <generator>Jekyll v3.6.2</generator>
    
      <item>
        <title>BBB Notebook 3 PWM 实验</title>
        <description>&lt;h1 id=&quot;beagleboard-black-笔记-3&quot;&gt;beagleboard black 笔记 &amp;lt;3&amp;gt;&lt;/h1&gt;

&lt;h1 id=&quot;几个基于例程的实验&quot;&gt;几个基于例程的实验&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;点亮板子上的灯，循环点亮，跑马灯效果。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;点亮外部的灯，IO口控制。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;基本的按键输入，简单的 Python 状态机。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过这几个实验可以基本的了解一下 BBB 的 IO 口功能，但是这样并不能让我们完全了解到 BBB 的优势 以及与 类似基本的诸如 51 或是 STM32 不同之处，例如目前始终不能使用的 PWM 波功能。那么接下来才是真正跳入 BBB 的坑的过程吧。&lt;/p&gt;

&lt;h2 id=&quot;使用ＰＷＭ波功能&quot;&gt;使用ＰＷＭ波功能&lt;/h2&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_7880d3350102wz2b.html&quot;&gt;Beaglebone Black开启PWM功能&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.teachmemicro.com/beaglebone-black-pwm-ubuntu-device-tree/&quot;&gt;Beaglebone Black PWM on Ubuntu&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/beagleboard/bb.org-overlays/&quot;&gt;beagleboard/bb.org-overlays&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;开始使用教程最多的-p9_14-pwm-io-口&quot;&gt;开始使用教程最多的 p9_14 pwm io 口&lt;/h2&gt;
&lt;p&gt;按照教程，发现在 /lib/firmware/　目录下面只有一个　am33xx_pwm.dtbo 的驱动文件，却没有其他的ＩＯ口驱动。
【这里就很明显的体现出了这种跑系统的板子和ＳＴＭ３２ 的区别，之前一直以为他俩差不多，没有仔细研究过设备树，覆盖层之类的概念。】&lt;/p&gt;

&lt;h3 id=&quot;编写一个覆盖层&quot;&gt;编写一个覆盖层&lt;/h3&gt;
&lt;p&gt;可以自己为ＩＯ口编写一个，但是为了尽快看到实验效果，我直接　git 了一个。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; git clone https://github.com/beagleboard/bb.org-overlays/tree/master/src/arm
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;进入目录编译移动驱动&quot;&gt;进入目录，编译，移动驱动。&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;dtc -O dtb -o BB-PWM1-00A0.dtbo -b 0 -@ BB-PWM1-00A0.dts

mv -i BB-PWM1-00A0.dtbo /lib/firmware
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;添加到-slots-里面去&quot;&gt;添加到 slots 里面去。&lt;/h3&gt;

 	echo am33xx_pwm &amp;gt; /sys/devices/platform/bone_capemgr/slots

&lt;pre&gt;&lt;code&gt;echo BB-PWM1 &amp;gt; /sys/devices/platform/bone_capemgr/slots
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;查看改变io口属性&quot;&gt;查看，改变IO口属性？&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cd /sys/devices/platform/ocp

config-pin -l P9.14

config-pin P9.14 pwm

cat ocp:P9_14_pinmux/state　查看属性
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;另外备注：在将cape-universaln插入槽中（slots）后，在
root@beaglebone:/sys/devices/platform/ocp/ocp:P9_14_pinmux
中将P9_14设置为pwm模式（#config-pin P9.14 pwm）后，需要在
/sys/class/pwm/pwmchip2中echo 0 &amp;gt; export，
这里为什么是pwmchip2，因为pwmchip2的地址0x4830_2000对应的是PWM1，echo 0是开启EHRPWM1A，echo 1是开启EHRPWM1B。具体地址映射可参见AM335x参考手册memory map部分。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我在使用时发现如下情况，应该改为　pwm３　后成功使用，其中原因留待解决。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/post_img/BBB-img/pwm3img.png&quot; alt=&quot;pwm3img&quot; title=&quot;pwm3img&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;可以使用在文件夹路径&quot;&gt;可以使用，在文件夹路径&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/sys/devices/platform/ocp/48302000.epwmss/48302200.pwm/pwm/pwmchip3/pwm0

或者

/sys/class/pwm/pwmchip3/pwm0

可以正常使用命令

 echo 0 &amp;gt; polarity 

 echo 20000000 &amp;gt; period 

 echo 1 &amp;gt; enable
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Tue, 14 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/beagleboard-black/2017/11/14/BBB-note3.html</link>
        <guid isPermaLink="true">http://localhost:4000/beagleboard-black/2017/11/14/BBB-note3.html</guid>
        
        
        <category>beagleboard-black</category>
        
      </item>
    
      <item>
        <title>BBB Notebook 2 Ubuntu 联网 - 时钟同步 - 开启远程桌面</title>
        <description>&lt;h1 id=&quot;beagleboard-black-笔记-2&quot;&gt;beagleboard black 笔记 &amp;lt;2&amp;gt;&lt;/h1&gt;
&lt;p&gt;在 Windows10 和 Ubuntu14.04 下的 BBB 操作。在 Ubuntu14.04 下的网络共享。&lt;/p&gt;

&lt;h2 id=&quot;系统&quot;&gt;系统&lt;/h2&gt;

&lt;h3 id=&quot;win10&quot;&gt;Win10&lt;/h3&gt;

&lt;h4 id=&quot;start-page&quot;&gt;start page&lt;/h4&gt;
&lt;p&gt;在 win10 下面使用 USB 插入电脑，我们很容易的按照教程 192.168.7.2 就能进入开始页面，使用 Petty 进入命令行。&lt;/p&gt;

&lt;h4 id=&quot;win-网络共享&quot;&gt;win 网络共享&lt;/h4&gt;
&lt;p&gt;按照教程在网络设置中打开网络共享就能使用，但是学校的锐捷实在是阻止进步的阶梯，许多锐捷和 Mxxx 类似的软件都不能开多网卡了。&lt;/p&gt;

&lt;h3 id=&quot;ubuntu1404&quot;&gt;Ubuntu14.04&lt;/h3&gt;
&lt;h4 id=&quot;start-page-1&quot;&gt;start page&lt;/h4&gt;
&lt;p&gt;在 Ubuntu14.04 下面使用 USB 插入电脑，并不能如意的进入开始页面 192.168.6.2  。使用 &lt;strong&gt;ifconfig&lt;/strong&gt;  查看下。。。&lt;/p&gt;

&lt;h4 id=&quot;ubuntu-网络共享&quot;&gt;Ubuntu 网络共享&lt;/h4&gt;
&lt;p&gt;在 Ubuntu 下的锐捷仍然禁止使用多网卡【MMP】，但是通过安装 mentohust ，配置好后是可以的。具体方法网上很多。&lt;/p&gt;

&lt;p&gt;ubuntu 成功联网后参考
&lt;a href=&quot;http://blog.csdn.net/pkuyjxu/article/details/44617511&quot;&gt;Beaglebone black 与ubuntu 通过usb网络共享&lt;/a&gt; 可以实现网络分享。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Step 1, Configuring BBB as follow shows:
route add default gw 192.168.7.1
vim /etc/resolv.conf  and add &quot;nameserver 8.8.8.8&quot; at the end.
Step 2, Configuring Ubuntu PC as following shows:
sudo su
#【wlan0】 is my internet facing interface, 【eth1】 is the BeagleBone USB connection
iptables --table nat --append POSTROUTING --out-interface 【wlan0】 -j MASQUERADE
iptables --append FORWARD --in-interface 【eth1】 -j ACCEPT
echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward
Step 3,  Test the internet in BBB as bellow shows:
ping 8.8.8.8
ping www.baidu.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用该教程时，先在 Ubuntu 下 &lt;strong&gt;ifconfig&lt;/strong&gt; 查看下当前使用电脑的是哪个网卡，按照自己使用的网卡修改命令。&lt;/p&gt;

&lt;h2 id=&quot;时钟同步&quot;&gt;时钟同步&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/hahachenchen789/article/details/52326688&quot;&gt;beaglebone black 时间调整&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.首先要设置时区，板子默认的时区文件在/etc/localtime文件中，将其删除：rm /etc/localtime
2.查看系统数据库中有哪些时区可供选择，命令：ls /usr/share/zoneinfo/Asia/
3.选择上海，将上海时区链接到localtime，
命令：ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
4.同步时间：在debian下，命令为： ntpdate-debian
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;if run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总是提示/etc/localtime文件已经存在&lt;/p&gt;

&lt;p&gt;用 ln -sf 覆盖掉。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;使用-vnc-显示器&quot;&gt;使用 VNC 显示器&lt;/h2&gt;
&lt;p&gt;从成本和硬件上考虑，外接一个显示器显得十分不方便，需要购买的器材有点多了。这时可以考虑使用 VNC 显示器，方便的是在　beagleboard black　的　debian 系统和 PC 的 Ubuntu 上都自带了相关的软件。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/qq_30897583/article/details/71195001&quot;&gt;通过ＶＮＣ远程接入BeagleBone Black桌面&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;bbb-上打开-vncserver&quot;&gt;BBB 上打开 vncserver&lt;/h3&gt;
&lt;p&gt;记住此时分配给的端口号&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/post_img/BBB-img/openvnc.png&quot; alt=&quot;vncserver&quot; title=&quot;vncserver&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;在-ubuntu-上配置remmina远程客户端&quot;&gt;在 Ubuntu 上配置Remmina远程客户端&lt;/h3&gt;
&lt;p&gt;配置时保证端口号一致，ssh高级设置可以选择性打开。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/post_img/BBB-img/vncPcset.png&quot; alt=&quot;vncPcset&quot; title=&quot;vncPcset&quot; /&gt;&lt;/p&gt;

&lt;p&gt;配置完成后即可进入。&lt;/p&gt;

&lt;h2 id=&quot;安装xfce４可选&quot;&gt;安装　Xfce４（可选）&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.douban.com/group/topic/42903996/&quot;&gt;install Xfce on Beaglebone Black &lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install xfce4
sudo apt-get install xfce-goodies 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成后重启，输入 startx or stearxfce4 启动，进入ＶＮＣ　即可看见界面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/post_img/BBB-img/tablexf.png&quot; alt=&quot;tablexf&quot; title=&quot;tablexf&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;problems-collection&quot;&gt;PROBLEMS COLLECTION&lt;/h2&gt;
&lt;p&gt;有时不知道自己搞的哪里坏了，在 cloud9 里面无法烧写程序，而是不断弹出错误，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tmux: need UTF-8 locale (LC_CTYPE) but have ANSI_X3.4-1968
tmux: invalid LC_ALL, LC_CTYPE or LANG
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应该是板子上的字符选择的错误，但是我没有找到什么好的方法，直接重装了系统。&lt;/p&gt;

&lt;h2 id=&quot;useful-resp&quot;&gt;useful resp&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/derekmolloy/exploringBB&quot;&gt;From book by Molloy&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;进入vnc桌面后有可能显示不全选择全屏才可以看见所有界面&quot;&gt;进入vnc桌面后有可能显示不全，选择全屏才可以看见所有界面&lt;/h1&gt;
&lt;p&gt;不要在这一步浪费太多时间&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/beagleboard-black/2017/11/09/BBB-note2.html</link>
        <guid isPermaLink="true">http://localhost:4000/beagleboard-black/2017/11/09/BBB-note2.html</guid>
        
        
        <category>beagleboard-black</category>
        
      </item>
    
      <item>
        <title> Pygame ConwayLifegame</title>
        <description>&lt;h1 id=&quot;conway-lifegame&quot;&gt;Conway Lifegame&lt;/h1&gt;
&lt;p&gt;经典的康威生命游戏，目前我看到了有两种完全不同的方法可以实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用 Pygame 来实现&lt;/li&gt;
  &lt;li&gt;使用 matplotlib 实现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过这两个方法各自的优点可以了解到两者不同的知识点。&lt;/p&gt;

&lt;h2 id=&quot;待续&quot;&gt;待续&lt;/h2&gt;
</description>
        <pubDate>Wed, 08 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/python/2017/11/08/pygame-ConwayLifegame.html</link>
        <guid isPermaLink="true">http://localhost:4000/python/2017/11/08/pygame-ConwayLifegame.html</guid>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>BBB Notebook 1 安装系统 - 正确关机 - 配置sublime Markdown</title>
        <description>&lt;h1 id=&quot;beagleboard-black-笔记-1&quot;&gt;beagleboard black 笔记 &amp;lt;1&amp;gt;&lt;/h1&gt;
&lt;p&gt;开始学习BBB，系统 window10，把 BBB 插入电脑后打开 192.168.7.2 会看到预计的网页效果，但是在使用 Cloud9  时会发现不能烧写程序进去，一堆 not found,cannot write,预计可能是自带的系统没有更新。&lt;/p&gt;

&lt;h2 id=&quot;更新系统&quot;&gt;更新系统&lt;/h2&gt;

&lt;p&gt;从BBB官网上下载，选择的是 Debain 的一个新的系统，下载网速奇慢无比。下载好后之后解压用官网推荐的把系统烧到 SD 卡里面。注意要在 Linux系统下把 /../uEnv.txt 最后一行注释#删掉。&lt;/p&gt;

&lt;p&gt;BBB 断电插入 SD 卡，按住靠近 SD 卡的按键按住不动，开电长按15s后开始跑马灯 0-1-2-3，3-2-1-0，表示正在烧系统。等待一会灯全熄灭了，启动BBB可以看到系统已经变成 Debain，程序也可正常烧写进板子了。&lt;/p&gt;

&lt;h2 id=&quot;查看系统信息&quot;&gt;查看系统信息&lt;/h2&gt;

&lt;h3 id=&quot;更新系统后通过命令查看系统状态&quot;&gt;更新系统后通过命令查看系统状态&lt;/h3&gt;

&lt;p&gt;1、# uname －a   （Linux查看版本当前操作系统内核信息）&lt;/p&gt;

&lt;p&gt;2、# cat /proc/version （Linux查看当前操作系统版本信息）&lt;/p&gt;

&lt;p&gt;3、# cat /etc/issue  或cat /etc/redhat-release（Linux查看版本当前操作系统发行版信息）&lt;/p&gt;

&lt;p&gt;4、# cat /proc/cpuinfo （Linux查看cpu相关信息，包括型号、主频、内核信息等）&lt;/p&gt;

&lt;p&gt;5、# getconf LONG_BIT  （Linux查看版本说明当前CPU运行在32bit模式下， 但不代表CPU不支持64bit）&lt;/p&gt;

&lt;p&gt;6、# lsb_release -a&lt;/p&gt;

&lt;h2 id=&quot;查看初始的密码&quot;&gt;查看初始的密码&lt;/h2&gt;

&lt;p&gt;Default username/password:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;username: debian
password: temppwd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From &lt;a href=&quot;https://elinux.org/BeagleBoardDebian&quot;&gt;Debian&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;如何正确关机&quot;&gt;如何正确关机？&lt;/h2&gt;
&lt;h3 id=&quot;关机方法&quot;&gt;关机方法&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;shutdown -h now&lt;/li&gt;
  &lt;li&gt;按电源键&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tips&quot;&gt;TIPS&lt;/h2&gt;
&lt;h3 id=&quot;sublime-配置&quot;&gt;sublime 配置&lt;/h3&gt;
&lt;p&gt;sublime 配置 markdown 时，安装Markdown Extend 后需要在&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;View -&amp;gt; Syntax -&amp;gt; Open all with current extension as... -&amp;gt; Markdown Extended
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中设置Markdown主题。&lt;/p&gt;

&lt;p&gt;Markdown Extend下载安装详见 &lt;a href=&quot;https://github.com/jonschlinkert/sublime-markdown-extended&quot;&gt;Markdown Extend&lt;/a&gt; 。&lt;/p&gt;

</description>
        <pubDate>Tue, 07 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/beagleboard-black/2017/11/07/BBB-note1.html</link>
        <guid isPermaLink="true">http://localhost:4000/beagleboard-black/2017/11/07/BBB-note1.html</guid>
        
        
        <category>beagleboard-black</category>
        
      </item>
    
      <item>
        <title> ABAQUS 模拟霍普金森杆应力波 </title>
        <description>&lt;p&gt;&lt;strong&gt;仅供参考交流，对计算结果的精确性不负任何责任&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;abaqus-模拟应力波传播&quot;&gt;ABAQUS 模拟应力波传播&lt;/h1&gt;

&lt;p&gt;材料常数：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/post_img/ABAQUS-BAR/CodeCogsEqn.gif&quot; alt=&quot;Impact&quot; title=&quot;Impact&quot; /&gt;&lt;/p&gt;

&lt;p&gt;杆尺寸：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;入射杆长度10，直径10；透射杆长度100，直径10；
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;结果&quot;&gt;结果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/post_img/ABAQUS-BAR/imapct.gif&quot; alt=&quot;Impact simulation&quot; title=&quot;Impact simulation&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;做个小笔记，记下分析步骤。&lt;/p&gt;

&lt;h2 id=&quot;assembly&quot;&gt;Assembly&lt;/h2&gt;
&lt;h3 id=&quot;两杆对心距离-5-&quot;&gt;两杆对心，距离 5 。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/post_img/ABAQUS-BAR/assembly.png&quot; alt=&quot;Assembly&quot; title=&quot;Assembly&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;step&quot;&gt;Step&lt;/h2&gt;
&lt;h3 id=&quot;定义分析步step1显示动力学分析修改时间&quot;&gt;定义分析步step1，&lt;strong&gt;显示动力学分析&lt;/strong&gt;，修改时间。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/post_img/ABAQUS-BAR/StepcontactDefine.png&quot; alt=&quot;StepcontactDefine&quot; title=&quot;StepcontactDefine&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;fieldoutputset-提高输出帧数&quot;&gt;FieldoutputSet 提高输出帧数。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/post_img/ABAQUS-BAR/FieldoutputSet.png&quot; alt=&quot;FieldoutputSet&quot; title=&quot;FieldoutputSet&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;historyoutput设置历史输出&quot;&gt;historyOutput，设置历史输出&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;输出目标为透射杆的应力 S33 和 速度 V3，方便结果绘图。可添加多个杆进行输出。&lt;/li&gt;
  &lt;li&gt;【注】历史变量输出太多计算中会报错，可减少输出或修改可输出最大值。
&lt;img src=&quot;/post_img/ABAQUS-BAR/historyOutput.png&quot; alt=&quot;historyOutput&quot; title=&quot;historyOutput&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;interaction&quot;&gt;Interaction&lt;/h2&gt;
&lt;h3 id=&quot;定义接触参数属性默认&quot;&gt;定义接触参数，属性默认。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/post_img/ABAQUS-BAR/contactPropertyDef.png&quot; alt=&quot;contactPropertyDef&quot; title=&quot;contactPropertyDef&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;选择接触面定义接触面属性&quot;&gt;选择接触面，定义接触面属性。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/post_img/ABAQUS-BAR/contactSurface.png&quot; alt=&quot;contactSurface&quot; title=&quot;contactSurface&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;load&quot;&gt;Load&lt;/h2&gt;
&lt;h3 id=&quot;定义边界条件锁定位移和旋转杆件只有轴向位移&quot;&gt;定义边界条件，锁定位移和旋转，杆件只有轴向位移。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/post_img/ABAQUS-BAR/boundaryConditionSet.png&quot; alt=&quot;boundaryConditionSet&quot; title=&quot;boundaryConditionSet&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;定义入射杆速度场&quot;&gt;定义入射杆速度场。&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;【注】速度场选择整个杆子的 set ，不是选择一个面。
&lt;img src=&quot;/post_img/ABAQUS-BAR/predefineField.png&quot; alt=&quot;predefineField&quot; title=&quot;predefineField&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;结果讨论&quot;&gt;结果讨论&lt;/h2&gt;
&lt;h3 id=&quot;在-t005-时开始碰撞产生一个压缩波&quot;&gt;在 T=0.05 时开始碰撞，产生一个压缩波。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/post_img/ABAQUS-BAR/timeImpact.png&quot; alt=&quot;timeImpact&quot; title=&quot;timeImpact&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;压缩波反射形成拉伸波&quot;&gt;压缩波反射形成拉伸波。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/post_img/ABAQUS-BAR/TensileWave.png&quot; alt=&quot;TensileWave&quot; title=&quot;TensileWave&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;杆上速度和应力变化&quot;&gt;杆上速度和应力变化。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/post_img/ABAQUS-BAR/Wave.png&quot; alt=&quot;Wave&quot; title=&quot;Wave&quot; /&gt;
&lt;img src=&quot;/post_img/ABAQUS-BAR/Vectory.png&quot; alt=&quot;Vectory&quot; title=&quot;Vectory&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 01 Nov 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/abaqus/2017/11/01/stress-wave-abaqus.html</link>
        <guid isPermaLink="true">http://localhost:4000/abaqus/2017/11/01/stress-wave-abaqus.html</guid>
        
        
        <category>ABAQUS</category>
        
      </item>
    
      <item>
        <title> Pygame Notebook 7 总结</title>
        <description>&lt;h1 id=&quot;making-games-with-python-and-pygame&quot;&gt;《Making Games with Python and Pygame》&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;notebook-7-summary&quot;&gt;Notebook &amp;lt;7&amp;gt; Summary&lt;/h2&gt;
&lt;p&gt;经过近一周的阅读学习，这本书上前面几章的代码和内容大致就到这了。剩下的实在太长且重复了之前的一些内容，游戏的规则也渐渐复杂起来，留待以后慢慢研习。
至此关于 Pygame 中的一些基本函数和常用操作都差不多了解不少，现将前几章中代码中比较有技巧，有意思的部分复习整理一下留做记录。&lt;/p&gt;

&lt;h3 id=&quot;演示第二三四章中方块变化的效果&quot;&gt;演示第二三四章中方块变化的效果&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://localhost:4000/assets/files/Pygame_book/my_puzzleSlide_test.py&quot;&gt;运行文件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;小程序演示了方块的遮盖，还原。方块透明度的变化，通过贪吃蛇演示了动画制作的原理。&lt;/li&gt;
  &lt;li&gt;其中贪吃蛇和方块变化的 FPS 需要设置成不一样。&lt;/li&gt;
  &lt;li&gt;演示了鼠标各个按键滚轮的信号监听，键盘的信号监听。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/post_img/puzzle_slide.png&quot; alt=&quot;演示图&quot; title=&quot;演示图&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;第十章中翻转棋子的游戏是如何让检测棋子翻转的呢&quot;&gt;第十章中翻转棋子的游戏是如何让检测棋子翻转的呢？&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;巧妙的通过列表循环直接循环了棋子周围的8个方向并在循环中不断跟进查找直到终止本次跟进，找出不同的棋子放进待翻转的列表，最后在一起重新绘制。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;	for xdirection, ydirection in [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]]:
		x, y = xstart, ystart
		x += xdirection
		y += ydirection
		if isOnBoard(x, y) and board[x][y] == otherTile:
			# The piece belongs to the other player next to our piece.
			x += xdirection
			y += ydirection
			if not isOnBoard(x, y):
				continue
			while board[x][y] == otherTile:
				x += xdirection
				y += ydirection
				if not isOnBoard(x, y):
					break # break out of while loop, continue in for loop
			if not isOnBoard(x, y):
				continue
			if board[x][y] == tile:
				# There are pieces to flip over. Go in the reverse
				# direction until we reach the original space, noting all
				# the tiles along the way.
				while True:
					x -= xdirection
					y -= ydirection
					if x == xstart and y == ystart:
						break
					tilesToFlip.append([x, y])
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;第十一章中检测到不同颜色边沿和局部颜色闪烁是如何实现的呢&quot;&gt;第十一章中检测到不同颜色边沿和局部颜色闪烁是如何实现的呢？&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://localhost:4000/assets/files/Pygame_book/my_puzzlePartFlash_test.py&quot;&gt;演示文件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;先递归调用漫水算法找到不一致的方块，由于将列表作为了&lt;strong&gt;函数参数&lt;/strong&gt;且没有复制，在函数调用过程中直接被修改了内部的变量，该列表作为全局画图参数这样非但不影响，反而隐藏了一些潜在BUG，貌似有助于编程。&lt;/li&gt;
  &lt;li&gt;局部闪烁的原因是：即使在原来的颜色上闪烁人眼也不能察觉出来，如果在闪烁函数中加入一个全局的 DISPLAYSURF.fill(WHITE) 那么就可以就看出来其实是每个颜色都闪了。&lt;/li&gt;
  &lt;li&gt;演示中加入了实时显示鼠标位置的部分。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;第十章中四子棋的游戏是如何让检测成功的呢&quot;&gt;第十章中四子棋的游戏是如何让检测成功的呢？&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;循环全局 board，检测横竖撇捺四个方向是否有四个连成一线的。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;def isWinner(board, tile):
	# check horizontal spaces
	for x in range(BOARDWIDTH - 3):
		for y in range(BOARDHEIGHT):
			if board[x][y] == tile and board[x+1][y] == tile and board[x+2][y] == tile and board[x+3][y] == tile:
				return True
	# check vertical spaces
	for x in range(BOARDWIDTH):
		for y in range(BOARDHEIGHT - 3):
			if board[x][y] == tile and board[x][y+1] == tile and board[x][y+2] == tile and board[x][y+3] == tile:
				return True
	# check / diagonal spaces
	for x in range(BOARDWIDTH - 3):
		for y in range(3, BOARDHEIGHT):
			if board[x][y] == tile and board[x+1][y-1] == tile and board[x+2][y-2] == tile and board[x+3][y-3] == tile:
				return True
	# check \ diagonal spaces
	for x in range(BOARDWIDTH - 3):
		for y in range(BOARDHEIGHT - 3):
			if board[x][y] == tile and board[x+1][y+1] == tile and board[x+2][y+2] == tile and board[x+3][y+3] == tile:
				return True
	return False

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;第十章的游戏是如何让电脑决定下一步的呢&quot;&gt;第十章的游戏是如何让电脑决定下一步的呢？&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;AI。&lt;/li&gt;
  &lt;li&gt;暴力搜索最佳。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;鼠标按住拖动显示后松开物体下降&quot;&gt;鼠标按住拖动显示，后松开物体下降。&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://localhost:4000/assets/files/Pygame_book/my_takenDrop_test.py&quot;&gt;演示文件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;MOUSEBUTTONDOWN，MOUSEBUTTONUP，MOUSEMOTION。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;待续&quot;&gt;待续&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;一些音乐播放，图片加载，背景闪烁，背景贴图效果可以看前面的几节内容。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 30 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/python/2017/10/30/pygame-note_sum.html</link>
        <guid isPermaLink="true">http://localhost:4000/python/2017/10/30/pygame-note_sum.html</guid>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title> Pygame Notebook 6 推箱子</title>
        <description>&lt;h1 id=&quot;making-games-with-python-and-pygame&quot;&gt;《Making Games with Python and Pygame》&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;notebook-6-推箱子&quot;&gt;Notebook &amp;lt;6&amp;gt; 推箱子&lt;/h2&gt;
&lt;p&gt;第九章的游戏 Star Pusher 经典的推箱子游戏。背景比松鼠游戏更加绚丽，物体也更加多样，虽然看上去都是贴图。人物推星星时星星的移动，一格一格。推到角落就不能在推了。推到了指定位置就进入下一关，通过读取关卡文件进行游戏地图绘制。&lt;/p&gt;

&lt;p&gt;第十章的介绍了几个更加复杂的游戏，代码量更多更庞杂。以后慢慢细看吧。&lt;/p&gt;

&lt;h3 id=&quot;亮点--思路&quot;&gt;亮点 / 思路&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;复杂广泛的背景贴图，关卡文件的意义。&lt;/li&gt;
  &lt;li&gt;胜负的判断。&lt;/li&gt;
  &lt;li&gt;能不能移动的判断。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;去除关卡文件中的注释行&quot;&gt;去除关卡文件中的注释行&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;读取文件，删除 ‘；’开始的行。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;line.find(';') #找到；开始的行，返回第一个 ； 的index = 0
line = line[:line.find(';')] #line 为空
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;待续&quot;&gt;待续。。。&lt;/h3&gt;

&lt;h2 id=&quot;监听鼠标事件&quot;&gt;监听鼠标事件&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;event.type 中的 MOUSEBUTTONUP 和 MOUSEBUTTONDOWN 包含了按动/松开 左键（1），滚轮（2），右键（3），上滚（4），下滚（5）的事件。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;for event in pygame.event.get(): # event handling loop
	if event.type == MOUSEBUTTONUP:
		if event.button == 1 or event.button ==4:
			# do something
		if event.button == 3 or event.button ==5:
			# do something
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 30 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/python/2017/10/30/pygame-note6.html</link>
        <guid isPermaLink="true">http://localhost:4000/python/2017/10/30/pygame-note6.html</guid>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title> Pygame Notebook 5 大鱼吃小鱼</title>
        <description>&lt;h1 id=&quot;making-games-with-python-and-pygame&quot;&gt;《Making Games with Python and Pygame》&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;notebook-5&quot;&gt;Notebook &amp;lt;5&amp;gt;&lt;/h2&gt;
&lt;p&gt;第八章的游戏 Squrrile 大鱼吃小鱼。本次游戏从代码量上看来比俄罗斯方块少了不少，但是游戏界面看上去比较像模像样了。
背景会随着方向的移动而变化，松鼠也会跳跃着移动。屏幕上也有其他移动方向和大小随机的松鼠。有了血条显示松鼠的生命值。死亡后界面上仍有松鼠移动，当松鼠变到很大时会有提示；生命值结束一段时间后自动重新开始。&lt;/p&gt;

&lt;p&gt;第八章的游戏看上去更加漂亮和丰富。&lt;/p&gt;

&lt;h3 id=&quot;亮点--思路&quot;&gt;亮点 / 思路&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;松鼠属性的字典表示，更加直观专业。&lt;/li&gt;
  &lt;li&gt;相机视角造成了一种窗口移动的效果。&lt;/li&gt;
  &lt;li&gt;受伤后的闪烁，无敌状态。&lt;/li&gt;
  &lt;li&gt;动画效果仍然是每次重新绘制所有。&lt;/li&gt;
  &lt;li&gt;有效界面的判断，界面外生成物体形成突然进入的效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;松鼠的表示&quot;&gt;松鼠的表示&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;使用字典存储了所有的属性。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;playerObj = {'surface': pygame.transform.scale(L_SQUIR_IMG, (STARTSIZE, STARTSIZE)),
	'facing': LEFT,
	'size': STARTSIZE,
	'x': HALF_WINWIDTH,
	'y': HALF_WINHEIGHT,
	'bounce':0,
	'health': MAXHEALTH}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;视角的移动相机的延迟&quot;&gt;视角的移动，相机的延迟&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;相机所能看到的区域叫做相机视图，camera view，其中心位于游戏坐标的一点。由于相机看到的内容显示于玩家的屏幕上，相机坐标与像素坐标是相同的。要得到松鼠的像素坐标，即松鼠出现在屏幕上的位置，用松鼠的游戏坐标减去相机的原点坐标。&lt;/li&gt;
  &lt;li&gt;松鼠的移动实际上是松鼠与其他物体相对未知的移动，是基于相机坐标的移动上的相对移动。通过松鼠在界面上的位置，计算出一个“所谓”的相机坐标，将松鼠向左移动，另外&lt;strong&gt;物体的坐标减去相机坐标&lt;/strong&gt;则会向相反的方向移动，而界面大小是一定的，造成移动效果。&lt;/li&gt;
  &lt;li&gt;但是这样做，通过例子的观察看出，这样移动的坐标系与全局的坐标系或是界面的坐标系没有什么必然关联。若是在界面上提前定义好一个坐标确定的方块，方块将不随界面的”移动“。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://localhost:4000/assets/files/Pygame_book/my_camera_pos.py&quot;&gt;运行文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;松鼠的跳跃&quot;&gt;松鼠的跳跃&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;使用正弦函数值加载到 Y 坐标。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;闪烁效果&quot;&gt;闪烁效果&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;画一次，覆盖，再画一次，覆盖，重复的视觉暂留效果。&lt;/li&gt;
  &lt;li&gt;通过时间取余数来判断是否覆盖重画。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://localhost:4000/assets/files/Pygame_book/my_load_img.py&quot;&gt;运行文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;# flashIsOn is 1 or 0
flashIsOn = round(time.time(), 1) * 10 % 2 == 1
# 巧妙的逻辑判断
if not gameOverMode and not (invulnerableMode and flashIsOn):
	playerObj['rect'] = pygame.Rect( (playerObj['x'] - camerax, playerObj['y'] - cameray -
	getBounceAmount(playerObj['bounce'], BOUNCERATE, BOUNCEHEIGHT),
	playerObj['size'],playerObj['size']) )

	DISPLAYSURF.blit(playerObj['surface'], playerObj['rect'])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;函数用法&quot;&gt;函数用法&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;设置窗口标题栏图标，理想大小 32*32像素。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;pygame.display.set_icon(pygame.image.load('gameicon.png'))
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;加载图像，反转图像。&lt;/li&gt;
  &lt;li&gt;循环加载图像。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;L_SQUIR_IMG = pygame.image.load('squirrel.png')
R_SQUIR_IMG = pygame.transform.flip(L_SQUIR_IMG, True, False)

for i in range(1, 5):
	GRASSIMAGES.append(pygame.image.load('grass%s.png' % i))
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;设置窗口标题栏图标，理想大小 32*32像素。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;pygame.display.set_icon(pygame.image.load('gameicon.png'))
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;反向遍历列表删除元素，不会报错。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;for i in range(len(LIST)-1, -1, -1):
	del xxx
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 28 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/python/2017/10/28/pygame-note5.html</link>
        <guid isPermaLink="true">http://localhost:4000/python/2017/10/28/pygame-note5.html</guid>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title> Pygame Notebook 4 俄罗斯方块</title>
        <description>&lt;h1 id=&quot;making-games-with-python-and-pygame&quot;&gt;《Making Games with Python and Pygame》&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;notebook-4&quot;&gt;Notebook &amp;lt;4&amp;gt;&lt;/h2&gt;
&lt;p&gt;第七章的游戏 Tetromino 俄罗斯方块。背景区域的划分规划，背景音乐的播放。砖块的构造，下落，旋转，消失。砖块碰撞叠加的判断，游戏结束的判断。代码量接近前两章的两倍多，编写更加复杂了。&lt;/p&gt;

&lt;h3 id=&quot;亮点--思路&quot;&gt;亮点 / 思路&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;游戏板数据结构
    &lt;blockquote&gt;
      &lt;p&gt;游戏板数据结构是用来记录之前着陆的砖块占据了哪些矩形空格的一种数据表示。当前下落的砖块在游戏板数据结构中并没有标记。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;砖块的表示使用的是列表的列表，区分了 fallingOiece 和 nextPiece 。使用砖块用字典表示了，从界面的中点下降。&lt;/li&gt;
  &lt;li&gt;砖块的旋转是直接将砖块旋转的顺序按照列表的排列写进了砖块的表示中去了，直接查表不用计算了。&lt;/li&gt;
  &lt;li&gt;后台程序中给所有的界面方块赋予了一个 BLANK 值用于检测是否需要画上砖块。&lt;/li&gt;
  &lt;li&gt;砖块下降动画的制作仍然是重新绘制所有了。&lt;/li&gt;
  &lt;li&gt;砖块下降到何处就不能下降了，如何判断，如何加到游戏板数据结构中去？
    &lt;blockquote&gt;
      &lt;p&gt;通过isValidPosition() 判断砖块是否处于有效位置，如果返回 False 则说明砖块当前需要判断的位置无效&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;用程序运行间隔的时间来控制砖块下降的速度，通过调节阀值进行关卡的增加。&lt;/li&gt;
  &lt;li&gt;游戏结束的标准：下降砖块没有足够的放置空间，如何判断。&lt;/li&gt;
  &lt;li&gt;暂停事件按键抬起才触发，移动按下就触发，抬起才结束，可以一直移动不用按个不停。检测按键松开来判断玩家是否想要继续移动砖块，便于检查长按的情况。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;keydown-keypress-keyup--事件的区别&quot;&gt;keyDown keyPress keyUp  事件的区别&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_a401a1ea0101edah.html&quot; title=&quot;事件的区别&quot;&gt;事件区别&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;按键弹起才触发，按键按下就触发的区别就在这里。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;# 等待按键弹起？？？
def checkForKeyPress():
	# Go through event queue looking for a KEYUP event.
	# Grab KEYDOWN events to remove them from the event queue.
	checkForQuit()

	for event in pygame.event.get([KEYDOWN, KEYUP]):
		if event.type == KEYDOWN:
			continue
		return event.key
	return None
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;背景音乐一直播放&quot;&gt;背景音乐一直播放&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;使用 pygame.mixer.music。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;pygame.mixer.music.load('xxx')
pygame.mixer.music.play(-1, 0.0)
pygame.mixer.music.stop()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;砖块的表示和调用&quot;&gt;砖块的表示和调用&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;S_SHAPE_TEMPLATE 表示砖块及其可能的旋转表示，列表的列表。&lt;/li&gt;
  &lt;li&gt;PIECE 砖块组成的字典。&lt;/li&gt;
  &lt;li&gt;调用砖块时，又把砖块作为 piece 字典中的一个 value 值并增加其他的属性。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;PIECES = {'S': S_SHAPE_TEMPLATE, 'Z': Z_SHAPE_TEMPLATE, 'J': J_SHAPE_TEMPLATE, 'L': L_SHAPE_TEMPLATE,
	     'I': I_SHAPE_TEMPLATE,'O': O_SHAPE_TEMPLATE, 'T': T_SHAPE_TEMPLATE}
def getNewPiece():
	# return a random new piece in a random rotation and color
	shape = random.choice(list(PIECES.keys()))
	newPiece = {'shape': shape,
			'rotation': random.randint(0, len(PIECES[shape]) - 1),
			'x': int(BOARDWIDTH / 2) - int(TEMPLATEWIDTH / 2),
			'y': -2, # start it above the board (i.e. less than 0)
			'color': random.randint(0, len(COLORS)-1)}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;判断砖块需要处于的位置是否有效&quot;&gt;判断砖块需要处于的位置是否有效&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;A smart function&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;board 为游戏板数据结构，piece 为砖块位置，通过adjX,Y 调节从而判断砖块将要处于的位置是否有效。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;def isValidPosition(board, piece, adjX=0, adjY=0):
	# Return True if the piece is within the board and not colliding
	for x in range(TEMPLATEWIDTH):
		for y in range(TEMPLATEHEIGHT):
			#检测游戏板之外的方块
			isAboveBoard = y + piece['y'] + adjY &amp;lt; 0 
			if isAboveBoard or PIECES[piece['shape']][piece['rotation']][y][x] == BLANK:
				continue
			#检测砖块是否在游戏板上
			if not isOnBoard(x + piece['x'] + adjX, y + piece['y'] + adjY):
				return False
			#检测砖块的方块所在的游戏板空格不为空白
			#砖块上的空白和在检测时和游戏板上的空白检测并不冲突
			if board[x + piece['x'] + adjX][y + piece['y'] + adjY] != BLANK:
				return False
	return True

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;判断砖块是否到底或到不能再向下的位置&quot;&gt;判断砖块是否到底【或】到不能再向下的位置&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;仍然通过isValidPosition() 函数提前一格判断位置是否有效，如果无效了（到底了或是有阻挡），说明当前位置就是下落的最低位置，将砖块数据放入游戏板数据结构中，加分计算等级；如果是有效位置，就可以继续下降。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/post_img/tetromino1.png&quot; alt=&quot;ValidPosition&quot; title=&quot;ValidPosition&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;if time.time() - lastFallTime &amp;gt; fallFreq:
	# see if the piece has landed
	if not isValidPosition(board, fallingPiece, adjY=1):
		# falling piece has landed, set it on the board
		addToBoard(board, fallingPiece)
		score += removeCompleteLines(board)
		level, fallFreq = calculateLevelAndFallFreq(score)
		fallingPiece = None
	else:
		# piece did not land, just move the piece down
		fallingPiece['y'] += 1
		lastFallTime = time.time()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;检查删除和填满一行&quot;&gt;检查，删除和填满一行&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;判断所在行的空格是否存在 BLANK。&lt;/li&gt;
  &lt;li&gt;倒序检测所有行，如有一行填满，则将该行以上所有的内容向下复制赋值一遍，第 0 行填充 BLANK，此时 y 值不变，继续判断循环【方便了多行填满的情况】；没有则 y + 1。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;游戏结束的判断&quot;&gt;游戏结束的判断&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;仍然是isValidPosition() 函数。直接在旧砖块落底，新砖块初始落下时判断，如果一开始就没有足够空间，说明游戏结束了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;函数复习&quot;&gt;函数复习&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;在调用绘制函数以便让显示 Surface 对象看上去是你想要的方式之后，必须调用 update 让 显示 Surface 真正出现在用户显示器上。&lt;/p&gt;
  &lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;pygame.display.update()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 25 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/python/2017/10/25/pygame-note4.html</link>
        <guid isPermaLink="true">http://localhost:4000/python/2017/10/25/pygame-note4.html</guid>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title> Pygame Notebook 3 贪吃蛇</title>
        <description>&lt;h1 id=&quot;making-games-with-python-and-pygame&quot;&gt;《Making Games with Python and Pygame》&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;notebook-3&quot;&gt;Notebook &amp;lt;3&amp;gt;&lt;/h2&gt;
&lt;p&gt;第六章的游戏 Wormy 贪吃蛇游戏， 开局显示旋转变化的字体和方块，按下任意按键后会显示游戏界面，划分的网格，游走的蛇（绿色方块），苹果（红色的方块），碰撞到苹果身体变长，碰撞到自己和墙壁游戏结束，暂停并显示 Game Over，按下任意按键后又再次重新开始。同时实时显示分数。&lt;/p&gt;

&lt;h3 id=&quot;亮点--思路&quot;&gt;亮点 / 思路&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;程序很好的结合了吃苹果和游动的处理，使用蛇头坐标，一个字典列表表示蛇，每次都删除末尾，吃到则不删除。&lt;/li&gt;
  &lt;li&gt;Game Over时，进入显示Game Over while 死循环等待退出，其间其他的显示部分暂停在原处，死循环阻塞住了其他显示程序，显示程序仍旧在 Surface 上面显示界面，造成一种另外有暂停程序的假象。&lt;/li&gt;
  &lt;li&gt;字体背景会随着字体的变化而变化，不需要额外控制。&lt;/li&gt;
  &lt;li&gt;2D 图像的旋转，不完美，不应该直接覆盖变量，复用变量名的话则会造成字体的 Surface 越来越大，报错。&lt;/li&gt;
  &lt;li&gt;智能的退出函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;蛇的表示和长度的增加&quot;&gt;蛇的表示和长度的增加&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在当前的前进方向上增加头，删去尾巴，每次重新绘图时感觉就是在前进；吃到苹果则不删去，感觉就是增加了长度。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;wormCoords = [ {'x':startx , 'y': starty} ,  {'x':startx-1 , 'y': starty}  ,  {'x':startx-2 , 'y': starty} ,{'x':startx-3 , 'y': starty} ]
if wormCoords[HEAD]['x'] == apple['x'] and wormCoords[HEAD]['y'] == apple['y']:
	apple = getRandomLocation() # set a new apple somewhere
else:
	del wormCoords[-1] 

if direction == UP:
	newHead = {'x': wormCoords[HEAD]['x'], 'y': wormCoords[HEAD]['y'] - 1}
elif direction == DOWN:
	newHead = {'x': wormCoords[HEAD]['x'], 'y': wormCoords[HEAD]['y'] + 1}
elif direction == LEFT:
	newHead = {'x': wormCoords[HEAD]['x'] - 1, 'y': wormCoords[HEAD]['y']}
elif direction == RIGHT:
	newHead = {'x': wormCoords[HEAD]['x'] + 1, 'y': wormCoords[HEAD]['y']}

wormCoords.insert(0, newHead)

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;显示-pygameevent-中的-type-值&quot;&gt;显示 pygame.event 中的 type 值&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://localhost:4000/assets/files/Pygame_book/my_event_test.py&quot;&gt;运行文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;#/usr/bin/env python
#coding=utf8

import random, pygame, sys
from pygame.locals import *

WINDOWWIDTH = 640
WINDOWHEIGHT = 480

def main():
	pygame.init()
	DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))
	pygame.display.set_caption('event test')


	while True:
		for event in pygame.event.get():
			print 'event.type' , event.type

			if event.type == QUIT:
				pygame.quit()
				sys.exit()
			elif event.type == KEYDOWN:
				print event.key 

if __name__ == '__main__':
	main()

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;显示-文字旋转背景转化网格划分按键退出&quot;&gt;显示 文字旋转，背景转化，网格划分，按键退出&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://localhost:4000/assets/files/Pygame_book/my_wormy_test.py&quot;&gt;运行文件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;背景转化更好的说明了每次用背景色覆盖后重新绘图的原理和好处&lt;/li&gt;
  &lt;li&gt;文字旋转
    &lt;blockquote&gt;
      &lt;p&gt;pygame.transform.rotate( surface , rotate_angle) 并不会改变传递给它的 Surface 对象，而是返回一个新的Surface 对象，旋转后的图形绘制于新的 Surface 对象上。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以每次都重新绘图。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;旋转不要复用变量名。
    &lt;blockquote&gt;
      &lt;p&gt;pygame.error: Width or height is too large&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;退出函数 checkForKeyPress() 的使用&lt;/li&gt;
  &lt;li&gt;网格划分，循环划线。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Python&quot;&gt;#/usr/bin/env python
#coding=utf8

import random, pygame, sys
from pygame.locals import *

FPS = 5
WINDOWWIDTH = 640
WINDOWHEIGHT = 480
CELLSIZE = 20
assert WINDOWWIDTH % CELLSIZE == 0, &quot;Window width must be a multiple of cell size.&quot;
assert WINDOWHEIGHT % CELLSIZE == 0, &quot;Window height must be a multiple of cell size.&quot;
CELLWIDTH = int(WINDOWWIDTH / CELLSIZE)
CELLHEIGHT = int(WINDOWHEIGHT / CELLSIZE)
#	  R	G	B
WHITE	 = (255, 255, 255)
BLACK	 = (  0,   0,   0)
RED	   = (255,   0,   0)
GREEN	 = (  0, 255,   0)
DARKGREEN = (  0, 155,   0)
DARKGRAY  = ( 40,  40,  40)
BGCOLOR = BLACK
def terminate():
	pygame.quit()
	sys.exit()
def main():
	global FPSCLOCK, DISPLAYSURF, BASICFONT
	pygame.init()
	FPSCLOCK = pygame.time.Clock()
	DISPLAYSURF = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))
	BASICFONT = pygame.font.Font('freesansbold.ttf', 18)
	pygame.display.set_caption('Wormy')

	degrees1 = 0
	degrees2 = 0
	while True:	
		showStartScreen()
		showGameOverScreen()
def drawGrid():
	for x in range(0, WINDOWWIDTH, CELLSIZE): # draw vertical lines
		pygame.draw.line(DISPLAYSURF, DARKGRAY, (x, 0), (x, WINDOWHEIGHT))
	for y in range(0, WINDOWHEIGHT, CELLSIZE): # draw horizontal lines
		pygame.draw.line(DISPLAYSURF, DARKGRAY, (0, y), (WINDOWWIDTH, y))
def drawPressKeyMsg():
	pressKeySurf = BASICFONT.render('Press a key to play.', True, DARKGRAY)
	pressKeyRect = pressKeySurf.get_rect()
	pressKeyRect.topleft = (WINDOWWIDTH - 200, WINDOWHEIGHT - 30)
	DISPLAYSURF.blit(pressKeySurf, pressKeyRect)
def checkForKeyPress():
	if len(pygame.event.get(QUIT)) &amp;gt; 0:
		terminate()
	keyUpEvents = pygame.event.get(KEYUP)
	if len(keyUpEvents) == 0:
		return None
	if keyUpEvents[0].key == K_ESCAPE:
		terminate()
	return keyUpEvents[0].key
def showStartScreen():
	titleFont = pygame.font.Font('freesansbold.ttf', 100)
	titleSurf1 = titleFont.render('Wormy!', True, WHITE, DARKGREEN)
	titleSurf2 = titleFont.render('Wormy!', True, GREEN)
	while True:
		DISPLAYSURF.fill(BGCOLOR)
		rotatedSurf1 = pygame.transform.rotate(titleSurf1, degrees1) #返回的是新的 Surface 对象
		rotatedRect1 = rotatedSurf1.get_rect()
		rotatedRect1.center = (WINDOWWIDTH / 2, WINDOWHEIGHT / 2)
		DISPLAYSURF.blit(rotatedSurf1, rotatedRect1)
		rotatedSurf2 = pygame.transform.rotate(titleSurf2, degrees2) 
		rotatedRect2 = rotatedSurf2.get_rect()
		rotatedRect2.center = (WINDOWWIDTH / 2, WINDOWHEIGHT / 2)
		DISPLAYSURF.blit(rotatedSurf2, rotatedRect2)
		# for event in pygame.event.get():
		# 	if event.type == QUIT:
		# 		terminate()
		if checkForKeyPress():
			pygame.event.get() # clear event queue
			return
		drawPressKeyMsg()
		drawGrid()
		pygame.display.update()
		FPSCLOCK.tick(FPS)
		degrees1 += 3 # rotate by 3 degrees each frame
		degrees2 += 7 # rotate by 7 degrees each frame
def showGameOverScreen():
	gameOverFont = pygame.font.Font('freesansbold.ttf', 150)
	gameSurf = gameOverFont.render('Game', True, WHITE)
	overSurf = gameOverFont.render('Over', True, WHITE)
	gameRect = gameSurf.get_rect()
	overRect = overSurf.get_rect()
	gameRect.midtop = (WINDOWWIDTH / 2, 10)
	overRect.midtop = (WINDOWWIDTH / 2, gameRect.height + 10 + 25)

	DISPLAYSURF.blit(gameSurf, gameRect)
	DISPLAYSURF.blit(overSurf, overRect)

	drawPressKeyMsg()

	pygame.display.update()
	pygame.time.wait(500)
	checkForKeyPress() # clear out any key presses in the event queue

	while True:
		if checkForKeyPress():
			pygame.event.get() # clear event queue
			return
if __name__ == '__main__':
	main()
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 23 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/python/2017/10/23/pygame-note3.html</link>
        <guid isPermaLink="true">http://localhost:4000/python/2017/10/23/pygame-note3.html</guid>
        
        
        <category>Python</category>
        
      </item>
    
  </channel>
</rss>
